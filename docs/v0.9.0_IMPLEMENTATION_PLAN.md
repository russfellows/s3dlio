# v0.9.0 API-Stable Beta Release Plan

**Date**: October 7, 2025  
**Target Version**: v0.9.0  
**Status**: In Progress  
**Strategy**: API Stability - This is the last release with breaking changes before 1.0.0

---

## üéØ Release Strategy: Include ALL Breaking Changes Now

This is a **major strategic release** that establishes API stability from 0.9.0 ‚Üí 0.9.x ‚Üí 1.0.0. After this release, **NO breaking changes** will be made until v2.0.0.

### Why v0.9.0 is Critical

- **API Stability Commitment**: After v0.9.0, only bug fixes and non-breaking enhancements
- **Beta Quality**: This is the API-stable beta before production-ready v1.0.0
- **Developer Confidence**: Users can depend on stable APIs from 0.9.0 onwards
- **Versioning Path**: 0.9.0 ‚Üí 0.9.1 ‚Üí 0.9.2 ‚Üí ... ‚Üí 1.0.0 (no breaking changes)

---

## üìã Breaking Changes in v0.9.0

### 1. **Python Loader API** (BREAKING)
- **Before**: Returns single `bytes` for `batch_size=1`, `list[bytes]` for `batch_size>1`
- **After**: Always returns `list[bytes]` regardless of batch size
- **Rationale**: Type stability for ML frameworks (PyTorch, JAX, TensorFlow)
- **Migration**: Users must handle `list[bytes]` even for single items

### 2. **Rust ObjectStore Trait** (BREAKING)
- **Before**: `async fn get(&self, uri: &str) -> Result<Vec<u8>>`
- **After**: `async fn get(&self, uri: &str) -> Result<Bytes>`
- **Rationale**: Zero-copy performance, eliminates unnecessary allocations
- **Migration**: Rust users calling ObjectStore methods must handle `Bytes` instead of `Vec<u8>`

---

## üöÄ Major Architectural Changes

### 3. **Backend-Agnostic Range Engine**
- **Current**: RangeEngine only works with S3 (ShardedS3Clients)
- **New**: All backends (S3, GCS, Azure, File, DirectIO) use high-performance range engine
- **Impact**: 30-50% throughput improvement for large files on non-S3 backends
- **Implementation**: New `RangeGetBackend` trait with 5 backend implementations

### 4. **Concurrent Batch Loading**
- **Current**: Batch items fetched serially (one at a time)
- **New**: Concurrent fetching within each batch using JoinSet + Semaphore
- **Impact**: 3-8x faster Python data loading on object stores
- **Configuration**: New `num_workers` parameter (default: 8)

### 5. **Adaptive Performance Tuning**
- **Dynamic Part Sizing**: Auto-tune multipart chunk size (16MB/32MB/64MB) based on file size + network speed
- **Adaptive Concurrency**: Auto-select optimal `--jobs` based on backend, object count, workload
- **Configuration**: Environment variables for 100Gb infrastructure tuning

---

## üì¶ Implementation Stages (30 Tasks, 5 Local Commits)

### STAGE 1: Python Loader Improvements (Tasks 1-6)

**Objective**: Improve Python data loading performance and API consistency

**Tasks**:
1. Create `feature/v0.9.0-api-stable-beta` branch
2. Add `num_workers: Option<usize>` to LoaderOptions (additive, not breaking)
3. Implement concurrent batch fetching with JoinSet + Semaphore
4. **BREAKING**: Modify `__anext__` to always return `list[bytes]`
5. Test Python API changes (verify batch_size=1 returns list)
6. Commit locally: `feat(v0.9.0-stage1): Python loader concurrent batching and stable return type`

**Files Modified**:
- `src/python_api/python_aiml_api.rs`

**Expected Impact**:
- 3-8x faster batch loading on object stores
- Type-stable API for ML frameworks
- Configurable concurrency per workload

---

### STAGE 2: ObjectStore Bytes Migration (Tasks 7-12)

**Objective**: Eliminate unnecessary memory copies in Rust API

**Tasks**:
7. **BREAKING**: Change `ObjectStore::get()` and `get_range()` to return `Bytes`
8. Update all 5 backend implementations (S3, GCS, Azure, File, DirectIO)
9. Update Python API wrappers to handle `Bytes`
10. Update internal code (range_engine, data_loader, examples, tests)
11. Test Bytes migration (verify zero warnings, Python still works)
12. Commit locally: `feat(v0.9.0-stage2): Migrate ObjectStore to Bytes for zero-copy performance`

**Files Modified**:
- `src/object_store.rs` (trait + 3 implementations)
- `src/file_store.rs`
- `src/file_store_direct.rs`
- `src/python_api/python_core_api.rs`
- `src/python_api/python_aiml_api.rs`
- `src/python_api/python_advanced_api.rs`
- `src/range_engine.rs`
- `examples/*.rs`
- `tests/*.rs`

**Expected Impact**:
- 10-15% memory reduction
- Fewer allocations
- Better cache utilization

---

### STAGE 3: Backend-Agnostic Range Engine (Tasks 13-19)

**Objective**: Enable all backends to use high-performance concurrent range GET

**Tasks**:
13. Create `src/backend_trait.rs` with `RangeGetBackend` trait
14. Implement `RangeGetBackend` for S3 (wrap ShardedS3Clients)
15. Implement `RangeGetBackend` for File/DirectIO (thread pool + pread)
16. Implement `RangeGetBackend` for Azure/GCS (wrap existing get_range)
17. Update `RangeEngine` to use `Arc<dyn RangeGetBackend>`
18. Add tests for range operations on all backends
19. Commit locally: `feat(v0.9.0-stage3): Backend-agnostic range engine for performance parity`

**Files Modified**:
- `src/backend_trait.rs` (new file)
- `src/range_engine.rs`
- `src/s3_ops.rs`
- `src/file_store.rs`
- `src/file_store_direct.rs`
- `src/azure_client.rs`
- `src/gcs_client.rs`
- `src/lib.rs`
- `tests/test_range_engine.rs` (new tests)

**Expected Impact**:
- 30-50% throughput improvement for large files on File/Azure/GCS
- Backend performance parity (S3 no longer privileged)
- Consistent high-performance API across all backends

---

### STAGE 4: Adaptive Performance Tuning (Tasks 20-24)

**Objective**: Auto-tune performance parameters based on workload

**Tasks**:
20. Create `src/adaptive_config.rs` module
21. Integrate dynamic part sizing in put_multipart (16MB/32MB/64MB logic)
22. Integrate adaptive concurrency in CLI (auto-tune --jobs)
23. Test adaptive tuning (verify environment variables work)
24. Commit locally: `feat(v0.9.0-stage4): Adaptive performance tuning - dynamic part sizing and concurrency`

**Files Modified**:
- `src/adaptive_config.rs` (new file)
- `src/s3_ops.rs` (put_multipart)
- `src/gcs_client.rs` (put_multipart)
- `src/azure_client.rs` (put_multipart)
- `src/bin/cli.rs` (list, delete, copy commands)
- `src/lib.rs`

**Expected Impact**:
- 20-40% faster uploads on 100Gb infrastructure
- Optimal concurrency without manual tuning
- Environment-based configuration for different deployments

**Environment Variables**:
- `S3DLIO_NETWORK_SPEED_GBPS` - Network speed for part size calculation (default: 10)
- `S3DLIO_MIN_PART_SIZE` - Minimum part size override
- `S3DLIO_LOADER_NUM_WORKERS` - Concurrent workers for batch loading

---

### FINAL: Documentation & Release (Tasks 25-30)

**Objective**: Complete version bump, documentation, and testing

**Tasks**:
25. Version bump: `Cargo.toml` and `pyproject.toml` ‚Üí 0.9.0
26. Update `docs/Changelog.md` with comprehensive v0.9.0 release notes
27. Create `docs/CONFIGURATION.md` with environment variable guide
28. Final comprehensive testing (Rust + Python, all backends)
29. Create `/tmp/v0.9.0_Final_Commit.md` with migration guide
30. Final commit and prepare for push (DO NOT push until approved)

**Files Modified**:
- `Cargo.toml`
- `pyproject.toml`
- `docs/Changelog.md`
- `docs/CONFIGURATION.md` (new file)

---

## üéØ Expected Performance Impact

### Python Data Loading
- **3-8x faster** batch loading on object stores (latency hiding via concurrency)
- Better link utilization (concurrent requests)
- Configurable parallelism per workload

### Large File Operations
- **30-50% faster** range GET on File/Azure/GCS backends (range engine parity)
- **20-40% faster** uploads on 100Gb infrastructure (dynamic part sizing)
- **10-15% memory reduction** (Bytes instead of Vec<u8>)

### Resource Utilization
- Optimal concurrency auto-tuning
- Reduced manual configuration
- Better CPU and network efficiency

---

## üìö Testing Strategy

### Stage 1 Testing
```bash
# Build Python extension
./build_pyo3.sh && ./install_pyo3_wheel.sh

# Test loader changes
python python/tests/test_functionality.py

# Verify batch_size=1 returns list[bytes]
python -c "
import asyncio
from s3dlio import PyDataset, PyLoaderOptions
# Test code here
"
```

### Stage 2 Testing
```bash
# Rust tests
cargo test --release --lib
cargo clippy --all-targets

# Verify zero warnings
cargo build --release 2>&1 | grep -i warning

# Python still works
./build_pyo3.sh && ./install_pyo3_wheel.sh
python python/tests/test_functionality.py
```

### Stage 3 Testing
```bash
# Range engine tests for all backends
cargo test --release test_range_engine_all_backends

# Backend-specific range tests
cargo test --release test_file_range_operations
cargo test --release test_s3_range_operations
cargo test --release test_gcs_range_operations
cargo test --release test_azure_range_operations
```

### Stage 4 Testing
```bash
# Dynamic part sizing
export S3DLIO_NETWORK_SPEED_GBPS=100
# Upload large file and verify 64MB parts used

# Adaptive concurrency
./target/release/s3-cli ls -r s3://bucket/
# Verify optimal --jobs automatically selected

# Environment overrides
export S3DLIO_MIN_PART_SIZE=67108864
# Verify override respected
```

### Final Testing
```bash
# Full test suite
cargo test --release --lib
cargo test --release --bins
cargo clippy --all-targets --all-features
cargo build --release  # ZERO warnings required

# Python full suite
./build_pyo3.sh && ./install_pyo3_wheel.sh
python python/tests/test_functionality.py
python examples/enhanced_api_examples.py
```

---

## üìù Migration Guide (for v0.9.0 Users)

### Python API Changes

**Before (v0.8.x)**:
```python
# batch_size=1 returned single bytes object
async for item in loader:
    if isinstance(item, bytes):
        batch = [item]
    else:
        batch = item
```

**After (v0.9.0)**:
```python
# Always returns list[bytes]
async for batch in loader:
    # batch is always list[bytes]
    for item in batch:
        process(item)
```

### Rust API Changes

**Before (v0.8.x)**:
```rust
let store = store_for_uri("s3://bucket/")?;
let data: Vec<u8> = store.get("key").await?;
```

**After (v0.9.0)**:
```rust
use bytes::Bytes;

let store = store_for_uri("s3://bucket/")?;
let data: Bytes = store.get("key").await?;

// Convert to Vec<u8> only if ownership needed
let vec: Vec<u8> = data.to_vec();
```

---

## üö¶ Commit Strategy

All commits will be made **locally** to the `feature/v0.9.0-api-stable-beta` branch:

1. **Stage 1 Commit**: Python loader improvements
2. **Stage 2 Commit**: Bytes migration
3. **Stage 3 Commit**: Backend-agnostic range engine
4. **Stage 4 Commit**: Adaptive performance tuning
5. **Final Commit**: Version bump, changelog, documentation

**Push Strategy**: After all 5 commits are complete and tested, review the full `git log` before pushing to GitHub.

---

## ‚úÖ Success Criteria

- [ ] All 30 tasks completed
- [ ] 5 local commits (4 stages + final)
- [ ] Zero compiler warnings (`cargo build --release`)
- [ ] All tests passing (Rust + Python)
- [ ] Comprehensive changelog with migration guide
- [ ] Configuration documentation complete
- [ ] Breaking changes clearly documented
- [ ] Ready for API stability commitment (0.9.x ‚Üí 1.0.0)

---

## üìÖ Timeline

**Estimated Effort**: 5-7 days of focused development

- **Stage 1**: 1 day (Python loader - relatively straightforward)
- **Stage 2**: 2 days (Bytes migration - affects many files)
- **Stage 3**: 2-3 days (Range engine trait - most complex)
- **Stage 4**: 1 day (Adaptive tuning - mostly config logic)
- **Final**: 1 day (Testing, documentation, polish)

---

## üéØ Post-v0.9.0 Roadmap

**Deferred to v0.9.x (Non-Breaking)**:
- Zero-copy Rust‚ÜíPython (PyMemoryView) - Opt-in feature
- String cloning reduction - Code quality improvement
- Async Azure client cleanup - Remove block_in_place
- Additional performance profiling and tuning

**Future v1.0.0 Requirements**:
- Production-grade error handling
- Comprehensive documentation
- Stability testing (run for 30+ days without issues)
- Security audit
- Performance benchmarks vs alternatives

**Never Until v2.0.0**:
- Breaking API changes
- Major trait refactors
- Public API removals

---

**Status**: Ready to begin implementation  
**Next Action**: Start STAGE 1 - Create branch and begin Python loader improvements
