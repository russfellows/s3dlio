// src/io_uring/backend.rs
//
// Linux io_uring backend for high-performance file I/O
// Simplified implementation focusing on correctness over complexity

use anyhow::{Context, Result};
use async_trait::async_trait;
use bytes::Bytes;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use tokio::fs;

use crate::object_store::{ObjectStore, ObjectMetadata};

/// Configuration for io_uring backend
#[derive(Debug, Clone)]
pub struct IoUringConfig {
    /// Queue depth for io_uring operations
    pub queue_depth: u32,
    /// Enable SQ polling for reduced system call overhead
    pub enable_sq_polling: bool,
    /// Root path for file operations
    pub root_path: PathBuf,
}

impl Default for IoUringConfig {
    fn default() -> Self {
        Self {
            queue_depth: 128,
            enable_sq_polling: false,
            root_path: PathBuf::from("/tmp/s3dlio-io-uring"),
        }
    }
}

impl IoUringConfig {
    /// Create high-performance configuration
    pub fn high_performance() -> Self {
        Self {
            queue_depth: 256,
            enable_sq_polling: true,
            root_path: PathBuf::from("/tmp/s3dlio-io-uring"),
        }
    }
}

/// Metrics for io_uring operations
#[derive(Debug, Default)]
struct IoUringMetrics {
    operations: AtomicU64,
    bytes_transferred: AtomicU64,
}

impl IoUringMetrics {
    fn record_operation(&self, bytes: u64) {
        self.operations.fetch_add(1, Ordering::Relaxed);
        self.bytes_transferred.fetch_add(bytes, Ordering::Relaxed);
    }
    
    fn operation_count(&self) -> u64 {
        self.operations.load(Ordering::Relaxed)
    }
}

/// Linux-specific io_uring file store
#[cfg(target_os = "linux")]
mod linux_impl {
    use super::*;
    
    /// io_uring-based file store for Linux
    pub struct IoUringFileStore {
        config: IoUringConfig,
        metrics: Arc<IoUringMetrics>,
    }
    
    impl IoUringFileStore {
        /// Create new io_uring file store
        pub fn new(config: IoUringConfig) -> Result<Self> {
            // Ensure root directory exists
            std::fs::create_dir_all(&config.root_path)
                .with_context(|| format!("Failed to create root directory: {:?}", config.root_path))?;
            
            Ok(Self {
                config,
                metrics: Arc::new(IoUringMetrics::default()),
            })
        }
        
        /// Get operation count
        pub fn operation_count(&self) -> u64 {
            self.metrics.operation_count()
        }
        
        /// Get current queue depth (configuration value)
        pub fn current_queue_depth(&self) -> u32 {
            self.config.queue_depth
        }
        
        /// Convert URI to local file path
        fn uri_to_path(&self, uri: &str) -> PathBuf {
            // Simple URI to path conversion - in production this would be more sophisticated
            let sanitized = uri.replace(['/', ':', '?', '#'], "_");
            self.config.root_path.join(sanitized)
        }
    }
    
    #[async_trait]
    impl ObjectStore for IoUringFileStore {
        async fn get(&self, uri: &str) -> Result<Vec<u8>> {
            let path = self.uri_to_path(uri);
            
            // For now, use regular tokio::fs until we can properly integrate io_uring
            // The complexity of integrating tokio_uring correctly is significant
            let data = fs::read(&path).await
                .with_context(|| format!("Failed to read file: {:?}", path))?;
            
            self.metrics.record_operation(data.len() as u64);
            Ok(data)
        }
        
        async fn put(&self, uri: &str, data: &[u8]) -> Result<()> {
            let path = self.uri_to_path(uri);
            
            // Ensure parent directory exists
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).await
                    .with_context(|| format!("Failed to create directory: {:?}", parent))?;
            }
            
            // Use regular tokio::fs for now
            fs::write(&path, data).await
                .with_context(|| format!("Failed to write file: {:?}", path))?;
            
            self.metrics.record_operation(data.len() as u64);
            Ok(())
        }
        
        async fn delete(&self, uri: &str) -> Result<()> {
            let path = self.uri_to_path(uri);
            
            fs::remove_file(&path).await
                .with_context(|| format!("Failed to delete file: {:?}", path))?;
                
            self.metrics.record_operation(0);
            Ok(())
        }
        
        async fn get_range(&self, uri: &str, offset: u64, length: Option<u64>) -> Result<Vec<u8>> {
            let path = self.uri_to_path(uri);
            let file = fs::File::open(&path).await
                .with_context(|| format!("Failed to open file: {:?}", path))?;
            
            let metadata = file.metadata().await
                .with_context(|| format!("Failed to get metadata: {:?}", path))?;
            
            let file_size = metadata.len();
            let actual_length = length.unwrap_or(file_size.saturating_sub(offset));
            let end_offset = std::cmp::min(offset + actual_length, file_size);
            
            if offset >= file_size {
                return Ok(Vec::new());
            }
            
            // Read the range - simplified implementation
            let data = fs::read(&path).await
                .with_context(|| format!("Failed to read file: {:?}", path))?;
            
            let start = offset as usize;
            let end = std::cmp::min(end_offset as usize, data.len());
            
            let result = data[start..end].to_vec();
            self.metrics.record_operation(result.len() as u64);
            Ok(result)
        }
        
        async fn put_multipart(&self, uri: &str, data: &[u8], _part_size: Option<usize>) -> Result<()> {
            // For file system backend, multipart is the same as regular put
            self.put(uri, data).await
        }
        
        async fn list(&self, uri_prefix: &str, recursive: bool) -> Result<Vec<String>> {
            let prefix_path = self.uri_to_path(uri_prefix);
            let mut results = Vec::new();
            
            if prefix_path.is_dir() {
                let mut entries = fs::read_dir(&prefix_path).await
                    .with_context(|| format!("Failed to read directory: {:?}", prefix_path))?;
                
                while let Some(entry) = entries.next_entry().await? {
                    let entry_path = entry.path();
                    if entry_path.is_file() {
                        if let Some(name) = entry_path.file_name().and_then(|n| n.to_str()) {
                            results.push(name.to_string());
                        }
                    } else if recursive && entry_path.is_dir() {
                        // Recursive listing would go here
                        if let Some(name) = entry_path.file_name().and_then(|n| n.to_str()) {
                            let sub_results = self.list(&format!("{}/{}", uri_prefix, name), recursive).await?;
                            for sub in sub_results {
                                results.push(format!("{}/{}", name, sub));
                            }
                        }
                    }
                }
            }
            
            Ok(results)
        }
        
        async fn stat(&self, uri: &str) -> Result<ObjectMetadata> {
            let path = self.uri_to_path(uri);
            let metadata = fs::metadata(&path).await
                .with_context(|| format!("Failed to get metadata: {:?}", path))?;
            
            Ok(ObjectMetadata {
                content_length: Some(metadata.len() as i64),
                last_modified: metadata.modified().ok()
                    .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
                    .map(|d| format!("{}", d.as_secs())),
                content_type: Some("application/octet-stream".to_string()),
                etag: None,
                content_encoding: None,
                cache_control: None,
                content_disposition: None,
                content_language: None,
                expires: None,
                metadata: std::collections::HashMap::new(),
            })
        }
        
        async fn delete_prefix(&self, uri_prefix: &str) -> Result<()> {
            let prefix_path = self.uri_to_path(uri_prefix);
            
            if prefix_path.exists() {
                if prefix_path.is_dir() {
                    fs::remove_dir_all(&prefix_path).await
                        .with_context(|| format!("Failed to remove directory: {:?}", prefix_path))?;
                } else {
                    fs::remove_file(&prefix_path).await
                        .with_context(|| format!("Failed to remove file: {:?}", prefix_path))?;
                }
            }
            
            Ok(())
        }
        
        async fn create_container(&self, name: &str) -> Result<()> {
            let container_path = self.config.root_path.join(name);
            fs::create_dir_all(&container_path).await
                .with_context(|| format!("Failed to create container: {:?}", container_path))?;
            Ok(())
        }
        
        async fn delete_container(&self, name: &str) -> Result<()> {
            let container_path = self.config.root_path.join(name);
            if container_path.exists() {
                fs::remove_dir_all(&container_path).await
                    .with_context(|| format!("Failed to delete container: {:?}", container_path))?;
            }
            Ok(())
        }
        
        async fn get_writer(&self, uri: &str) -> Result<Box<dyn crate::object_store::ObjectWriter>> {
            // For now, return an error as ObjectWriter implementation is complex
            anyhow::bail!("Object writer not implemented for io_uring backend")
        }
    }
}

// Non-Linux fallback
#[cfg(not(target_os = "linux"))]
mod linux_impl {
    use super::*;
    
    pub struct IoUringFileStore;
    
    impl IoUringFileStore {
        pub fn new(_config: IoUringConfig) -> Result<Self> {
            anyhow::bail!("io_uring is only available on Linux")
        }
        
        pub fn operation_count(&self) -> u64 { 0 }
        pub fn current_queue_depth(&self) -> u32 { 0 }
    }
}

pub use linux_impl::IoUringFileStore;rc/io_uring/backend.rs
//
// io_uring backend implementation for Linux

#[cfg(all(target_os = "linux", feature = "io-uring"))]
mod linux_impl {
    use anyhow::{Context, Result};
    use async_trait::async_trait;
    use bytes::Bytes;
    use std::path::{Path, PathBuf};
    use std::sync::Arc;
    use tokio_uring::fs::{File, OpenOptions};
    use crate::object_store::{ObjectStore, ObjectMetadata};
    
    /// Configuration for io_uring file operations
    #[derive(Debug, Clone)]
    pub struct IoUringConfig {
        /// Number of io_uring queue entries
        pub queue_depth: u32,
        /// Enable O_DIRECT for bypassing page cache
        pub use_direct_io: bool,
        /// Buffer alignment for O_DIRECT
        pub buffer_alignment: usize,
        /// Submission queue polling
        pub sq_poll: bool,
        /// Interrupt coalescing threshold
        pub cq_idle: Option<std::time::Duration>,
    }
    
    impl Default for IoUringConfig {
        fn default() -> Self {
            Self {
                queue_depth: 256,      // Moderate queue depth
                use_direct_io: false,  // Start conservative, can be enabled
                buffer_alignment: 4096, // 4KB alignment
                sq_poll: false,        // Kernel polling disabled by default
                cq_idle: None,         // No idle coalescing by default
            }
        }
    }
    
    impl IoUringConfig {
        /// High-performance configuration for fast storage
        pub fn high_performance() -> Self {
            Self {
                queue_depth: 512,
                use_direct_io: true,   // Bypass page cache
                buffer_alignment: 4096,
                sq_poll: true,         // Enable kernel polling
                cq_idle: Some(std::time::Duration::from_micros(1000)), // 1ms idle
            }
        }
        
        /// Configuration optimized for SSD storage
        pub fn ssd_optimized() -> Self {
            Self {
                queue_depth: 256,
                use_direct_io: true,
                buffer_alignment: 4096,
                sq_poll: false, // Let kernel decide
                cq_idle: None,
            }
        }
    }
    
    /// io_uring based file store implementation
    pub struct IoUringFileStore {
        config: IoUringConfig,
        runtime: tokio_uring::Runtime,
    }
    
    impl IoUringFileStore {
        pub fn new(config: IoUringConfig) -> Result<Self> {
            // Create io_uring runtime with specified configuration
            let mut builder = tokio_uring::builder();
            builder.entries(config.queue_depth);
            
            if config.sq_poll {
                builder.setup_sqpoll(1000); // 1ms idle before sleeping
            }
            
            let runtime = builder.build()
                .context("Failed to create io_uring runtime")?;
            
            log::info!("Created io_uring file store with queue depth: {}", config.queue_depth);
            
            Ok(Self { config, runtime })
        }
        
        /// Open file with appropriate flags for io_uring
        async fn open_file(&self, path: &Path, write: bool) -> Result<File> {
            let mut options = OpenOptions::new();
            
            if write {
                options.create(true).write(true).truncate(true);
            } else {
                options.read(true);
            }
            
            // Enable O_DIRECT if configured
            if self.config.use_direct_io {
                // Note: O_DIRECT requires special handling - buffers must be aligned
                // For now, we'll skip O_DIRECT and focus on io_uring benefits
                log::debug!("O_DIRECT requested but not yet implemented");
            }
            
            let file = options.open(path)
                .await
                .with_context(|| format!("Failed to open file: {:?}", path))?;
                
            Ok(file)
        }
        
        /// Read file using io_uring
        async fn read_file_uring(&self, path: &Path) -> Result<Bytes> {
            let file = self.open_file(path, false).await?;
            
            // Get file size
            let metadata = file.metadata().await
                .context("Failed to get file metadata")?;
            let size = metadata.len() as usize;
            
            // Allocate buffer
            let buf = vec![0u8; size];
            
            // Read entire file
            let (result, buf) = file.read_at(buf, 0).await;
            result.context("io_uring read failed")?;
            
            Ok(Bytes::from(buf))
        }
        
        /// Write file using io_uring
        async fn write_file_uring(&self, path: &Path, data: &[u8]) -> Result<()> {
            let file = self.open_file(path, true).await?;
            
            // Write data
            let (result, _) = file.write_at(data, 0).await;
            result.context("io_uring write failed")?;
            
            // Ensure data is flushed
            file.sync_all().await
                .context("Failed to sync file")?;
            
            Ok(())
        }
    }
    
    #[async_trait]
    impl ObjectStore for IoUringFileStore {
        async fn get(&self, path: &str) -> Result<Bytes> {
            let file_path = Path::new(path);
            self.read_file_uring(file_path).await
        }
        
        async fn put(&self, path: &str, data: Bytes) -> Result<()> {
            let file_path = Path::new(path);
            
            // Ensure parent directory exists
            if let Some(parent) = file_path.parent() {
                tokio::fs::create_dir_all(parent).await
                    .context("Failed to create parent directories")?;
            }
            
            self.write_file_uring(file_path, &data).await
        }
        
        async fn delete(&self, path: &str) -> Result<()> {
            let file_path = Path::new(path);
            tokio::fs::remove_file(file_path).await
                .with_context(|| format!("Failed to delete file: {:?}", file_path))
        }
        
        async fn head(&self, path: &str) -> Result<ObjectMetadata> {
            let file_path = Path::new(path);
            let metadata = tokio::fs::metadata(file_path).await
                .with_context(|| format!("Failed to get metadata for: {:?}", file_path))?;
                
            Ok(ObjectMetadata {
                key: path.to_string(),
                size: metadata.len(),
                last_modified: metadata.modified()
                    .unwrap_or(std::time::SystemTime::UNIX_EPOCH),
                e_tag: None,
                content_type: None,
                metadata: std::collections::HashMap::new(),
            })
        }
        
        async fn list_with_delimiter(&self, prefix: &str, _delimiter: Option<&str>) -> Result<Vec<ObjectMetadata>> {
            let dir_path = Path::new(prefix);
            let mut objects = Vec::new();
            
            let mut dir = tokio::fs::read_dir(dir_path).await
                .with_context(|| format!("Failed to read directory: {:?}", dir_path))?;
                
            while let Some(entry) = dir.next_entry().await
                .context("Failed to read directory entry")? {
                let path = entry.path();
                if path.is_file() {
                    let metadata = entry.metadata().await
                        .context("Failed to get entry metadata")?;
                        
                    objects.push(ObjectMetadata {
                        key: path.to_string_lossy().to_string(),
                        size: metadata.len(),
                        last_modified: metadata.modified()
                            .unwrap_or(std::time::SystemTime::UNIX_EPOCH),
                        e_tag: None,
                        content_type: None,
                        metadata: std::collections::HashMap::new(),
                    });
                }
            }
            
            Ok(objects)
        }
    }
    
    /// Create io_uring file store with configuration
    pub fn create_io_uring_file_store(config: IoUringConfig) -> Result<IoUringFileStore> {
        IoUringFileStore::new(config)
    }
}

#[cfg(all(target_os = "linux", feature = "io-uring"))]
pub use linux_impl::*;